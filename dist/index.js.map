{"version":3,"sources":["../src/types/index.ts","../src/utils/markdownUtils.ts","../src/utils/fileUtils.ts","../src/utils/searchUtils.ts","../src/tools/index.ts","../src/index.ts"],"names":["z","sanitizeHtml"],"mappings":"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","file":"index.js","sourcesContent":["import { z } from 'zod';\n\n// Zod schemas for runtime validation\nexport const ContentFileSchema = z.object({\n  path: z.string(),\n  name: z.string(),\n  content: z.string(),\n  frontmatter: z.record(z.unknown()).optional(),\n  lastModified: z.date(),\n  size: z.number().int().nonnegative()\n});\n\nexport const SearchResultSchema = z.object({\n  file: ContentFileSchema,\n  score: z.number().min(0).max(1),\n  matches: z.array(z.string())\n});\n\nexport const MarkdownProcessingOptionsSchema = z.object({\n  generateToc: z.boolean().default(true),\n  sanitizeHtml: z.boolean().default(true),\n  enableCodeHighlight: z.boolean().default(true)\n});\n\nexport const DocumentGenerationOptionsSchema = z.object({\n  template: z.string().optional(),\n  outputFormat: z.enum(['html', 'pdf', 'markdown']).default('html'),\n  includeMetadata: z.boolean().default(true),\n  customStyles: z.string().optional()\n});\n\nexport const NoteSearchOptionsSchema = z.object({\n  query: z.string().min(1),\n  directory: z.string().optional(),\n  includeContent: z.boolean().default(true),\n  maxResults: z.number().int().positive().default(10),\n  fuzzy: z.boolean().default(true)\n});\n\nexport const ContentStatsSchema = z.object({\n  totalFiles: z.number().int().nonnegative(),\n  totalSize: z.number().nonnegative(),\n  fileTypes: z.record(z.number().int().nonnegative()),\n  lastUpdated: z.date()\n});\n\n// TypeScript types inferred from Zod schemas\nexport type ContentFile = z.infer<typeof ContentFileSchema>;\nexport type SearchResult = z.infer<typeof SearchResultSchema>;\nexport type MarkdownProcessingOptions = z.infer<typeof MarkdownProcessingOptionsSchema>;\nexport type DocumentGenerationOptions = z.infer<typeof DocumentGenerationOptionsSchema>;\nexport type NoteSearchOptions = z.infer<typeof NoteSearchOptionsSchema>;\nexport type ContentStats = z.infer<typeof ContentStatsSchema>;\n\n// Utility function for safe parsing\nexport function parseWithSchema<T>(schema: z.ZodSchema<T>, data: unknown): T {\n  const result = schema.safeParse(data);\n  if (!result.success) {\n    throw new Error(`Validation failed: ${result.error.message}`);\n  }\n  return result.data;\n}\n","import { marked } from 'marked';\nimport type { MarkdownProcessingOptions } from '../types/index.js';\nimport { MarkdownProcessingOptionsSchema } from '../types/index.js';\n\n// Configure marked with safe defaults\nmarked.setOptions({\n  gfm: true,\n  breaks: true\n});\n\nexport function renderMarkdown(\n  content: string,\n  options: Partial<MarkdownProcessingOptions> = {}\n): string {\n  const opts = MarkdownProcessingOptionsSchema.parse(options);\n  \n  let processedContent = content;\n  \n  // Generate table of contents if requested\n  if (opts.generateToc) {\n    const toc = generateTableOfContents(content);\n    if (toc) {\n      processedContent = `${toc}\\n\\n${content}`;\n    }\n  }\n  \n  // Render markdown to HTML\n  const html = marked(processedContent);\n  \n  // Handle both sync and async returns from marked\n  if (html instanceof Promise) {\n    throw new Error('Async marked processing not supported in this function. Use async version.');\n  }\n  \n  // Sanitize HTML if requested (basic sanitization)\n  if (opts.sanitizeHtml) {\n    return sanitizeHtml(html);\n  }\n  \n  return html;\n}\n\nexport function generateTableOfContents(content: string): string | null {\n  const headings = extractHeadings(content);\n  \n  if (headings.length === 0) {\n    return null;\n  }\n  \n  const toc = headings\n    .map(({ level, text, id }) => {\n      const indent = '  '.repeat(level - 1);\n      return `${indent}- [${text}](#${id})`;\n    })\n    .join('\\n');\n    \n  return `## Table of Contents\\n\\n${toc}`;\n}\n\nexport function extractHeadings(content: string): Array<{\n  level: number;\n  text: string;\n  id: string;\n}> {\n  const headingRegex = /^(#{1,6})\\s+(.+)$/gm;\n  const headings: Array<{ level: number; text: string; id: string }> = [];\n  \n  let match;\n  while ((match = headingRegex.exec(content)) !== null) {\n    const level = match[1]?.length ?? 0;\n    const text = match[2]?.trim() ?? '';\n    const id = text\n      .toLowerCase()\n      .replace(/[^\\w\\s-]/g, '')\n      .replace(/\\s+/g, '-');\n      \n    headings.push({ level, text, id });\n  }\n  \n  return headings;\n}\n\nexport function extractFrontmatter(content: string): {\n  frontmatter: Record<string, unknown>;\n  content: string;\n} {\n  const frontmatterRegex = /^---\\s*\\n([\\s\\S]*?)\\n---\\s*\\n/;\n  const match = content.match(frontmatterRegex);\n  \n  if (!match) {\n    return { frontmatter: {}, content };\n  }\n  \n  try {\n    // Simple YAML parsing for frontmatter\n    const yamlContent = match[1] ?? '';\n    const frontmatter = parseSimpleYaml(yamlContent);\n    const contentWithoutFrontmatter = content.slice(match[0].length);\n    \n    return { frontmatter, content: contentWithoutFrontmatter };\n  } catch (error) {\n    console.warn('Failed to parse frontmatter:', error);\n    return { frontmatter: {}, content };\n  }\n}\n\n// Basic HTML sanitization (you might want to use a proper library like DOMPurify)\nfunction sanitizeHtml(html: string): string {\n  // Remove script tags and their content\n  html = html.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '');\n  \n  // Remove on* attributes (onclick, onload, etc.)\n  html = html.replace(/\\s*on\\w+\\s*=\\s*[\"'][^\"']*[\"']/gi, '');\n  \n  // Remove javascript: protocols\n  html = html.replace(/javascript:/gi, '');\n  \n  return html;\n}\n\n// Simple YAML parser for basic frontmatter\nfunction parseSimpleYaml(yaml: string): Record<string, unknown> {\n  const result: Record<string, unknown> = {};\n  const lines = yaml.split('\\n');\n  \n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed.startsWith('#')) continue;\n    \n    const colonIndex = trimmed.indexOf(':');\n    if (colonIndex === -1) continue;\n    \n    const key = trimmed.slice(0, colonIndex).trim();\n    let value: unknown = trimmed.slice(colonIndex + 1).trim();\n    \n    // Basic type inference\n    if (value === 'true') value = true;\n    else if (value === 'false') value = false;\n    else if (value === 'null') value = null;\n    else if (typeof value === 'string' && /^\\d+$/.test(value)) value = parseInt(value, 10);\n    else if (typeof value === 'string' && /^\\d+\\.\\d+$/.test(value)) value = parseFloat(value);\n    else if (typeof value === 'string') {\n      // Remove quotes if present\n      if ((value.startsWith('\"') && value.endsWith('\"')) ||\n          (value.startsWith(\"'\") && value.endsWith(\"'\"))) {\n        value = value.slice(1, -1);\n      }\n    }\n    \n    result[key] = value;\n  }\n  \n  return result;\n}\n","import { readFile, stat, readdir } from 'fs/promises';\nimport { join, extname, basename } from 'path';\nimport { glob } from 'glob';\nimport matter from 'gray-matter';\nimport type { ContentFile } from '../types/index.js';\n\nexport async function readContentFile(filePath: string): Promise<ContentFile> {\n  const content = await readFile(filePath, 'utf-8');\n  const stats = await stat(filePath);\n  \n  let frontmatter: Record<string, any> | undefined;\n  let processedContent = content;\n  \n  // Parse frontmatter if it exists\n  if (filePath.endsWith('.md') || filePath.endsWith('.markdown')) {\n    const parsed = matter(content);\n    frontmatter = parsed.data;\n    processedContent = parsed.content;\n  }\n  \n  return {\n    path: filePath,\n    name: basename(filePath),\n    content: processedContent,\n    frontmatter,\n    lastModified: stats.mtime,\n    size: stats.size\n  };\n}\n\nexport async function findContentFiles(\n  directory: string,\n  extensions: string[] = ['.md', '.markdown', '.txt', '.mdx']\n): Promise<string[]> {\n  const patterns = extensions.map(ext => `**/*${ext}`);\n  const files: string[] = [];\n  \n  for (const pattern of patterns) {\n    const matches = await glob(pattern, { cwd: directory, absolute: true });\n    files.push(...matches);\n  }\n  \n  return [...new Set(files)]; // Remove duplicates\n}\n\nexport async function getDirectoryStats(directory: string): Promise<{\n  totalFiles: number;\n  totalSize: number;\n  fileTypes: Record<string, number>;\n}> {\n  const files = await findContentFiles(directory);\n  const stats = {\n    totalFiles: files.length,\n    totalSize: 0,\n    fileTypes: {} as Record<string, number>\n  };\n  \n  for (const file of files) {\n    const fileStat = await stat(file);\n    stats.totalSize += fileStat.size;\n    \n    const ext = extname(file);\n    stats.fileTypes[ext] = (stats.fileTypes[ext] || 0) + 1;\n  }\n  \n  return stats;\n}\n\nexport function sanitizePath(path: string): string {\n  // Basic path sanitization to prevent directory traversal\n  return path.replace(/\\.\\.\\//g, '').replace(/\\.\\.\\\\\\\\/g, '');\n}\n\nexport function isMarkdownFile(filename: string): boolean {\n  const ext = extname(filename).toLowerCase();\n  return ['.md', '.markdown', '.mdx'].includes(ext);\n}","import Fuse from 'fuse.js';\nimport { readContentFile, findContentFiles } from './fileUtils';\nimport type { ContentFile, SearchResult, NoteSearchOptions } from '../types/index';\nimport { NoteSearchOptionsSchema, parseWithSchema } from '../types/index';\n\nexport async function searchNotes(\n  options: NoteSearchOptions\n): Promise<SearchResult[]> {\n  const validatedOptions = parseWithSchema(NoteSearchOptionsSchema, options);\n  const { query, directory = process.cwd(), includeContent, maxResults, fuzzy } = validatedOptions;\n  \n  // Find all content files in the directory\n  const filePaths = await findContentFiles(directory);\n  const files: ContentFile[] = [];\n  \n  // Read all files\n  for (const filePath of filePaths) {\n    try {\n      const file = await readContentFile(filePath);\n      files.push(file);\n    } catch (error) {\n      console.warn(`Failed to read file ${filePath}:`, error);\n      continue;\n    }\n  }\n  \n  if (fuzzy) {\n    return performFuzzySearch(files, query, maxResults || 10, includeContent || true);\n  } else {\n    return performExactSearch(files, query, maxResults || 10, includeContent || true);\n  }\n}\n\nfunction performFuzzySearch(\n  files: ContentFile[],\n  query: string,\n  maxResults: number,\n  includeContent: boolean\n): SearchResult[] {\n  const fuseOptions = {\n    keys: [\n      { name: 'name', weight: 0.4 },\n      { name: 'content', weight: 0.3 },\n      { name: 'frontmatter.title', weight: 0.2 },\n      { name: 'frontmatter.tags', weight: 0.1 }\n    ],\n    threshold: 0.3, // Lower is more strict\n    includeMatches: true,\n    includeScore: true,\n    minMatchCharLength: 2\n  };\n  \n  const fuse = new Fuse(files, fuseOptions);\n  const fuseResults = fuse.search(query, { limit: maxResults });\n  \n  return fuseResults.map((result): SearchResult => {\n    const file = includeContent ? result.item : { ...result.item, content: '' };\n    // @ts-ignore\n    const matches = extractMatches(result.matches || []);\n    \n    return {\n      file,\n      score: 1 - (result.score || 0), // Invert score so higher is better\n      matches\n    };\n  });\n}\n\nfunction performExactSearch(\n  files: ContentFile[],\n  query: string,\n  maxResults: number,\n  includeContent: boolean\n): SearchResult[] {\n  const results: SearchResult[] = [];\n  const queryLower = query.toLowerCase();\n  \n  for (const file of files) {\n    const matches: string[] = [];\n    let score = 0;\n    \n    // Search in filename\n    if (file.name.toLowerCase().includes(queryLower)) {\n      matches.push(`Filename: ${file.name}`);\n      score += 0.4;\n    }\n    \n    // Search in content\n    const contentLines = file.content.split('\\n');\n    for (let i = 0; i < contentLines.length; i++) {\n      const line = contentLines[i];\n      if (line && line.toLowerCase().includes(queryLower)) {\n        matches.push(`Line ${i + 1}: ${line.trim()}`);\n        score += 0.1;\n      }\n    }\n    \n    // Search in frontmatter\n    if (file.frontmatter) {\n      for (const [key, value] of Object.entries(file.frontmatter)) {\n        if (typeof value === 'string' && value.toLowerCase().includes(queryLower)) {\n          matches.push(`${key}: ${value}`);\n          score += 0.2;\n        }\n      }\n    }\n    \n    if (matches.length > 0) {\n      const resultFile = includeContent ? file : { ...file, content: '' };\n      results.push({\n        file: resultFile,\n        score: Math.min(score, 1), // Cap score at 1\n        matches: matches.slice(0, 5) // Limit matches per file\n      });\n    }\n  }\n  \n  // Sort by score and limit results\n  return results\n    .sort((a, b) => b.score - a.score)\n    .slice(0, maxResults);\n}\n\nfunction extractMatches(fuseMatches: any[]): string[] {\n  const matches: string[] = [];\n  \n  for (const match of fuseMatches) {\n    const { key, value } = match;\n    if (typeof value === 'string') {\n      const truncated = value.length > 100 ? `${value.substring(0, 100)}...` : value;\n      matches.push(`${key}: ${truncated}`);\n    }\n  }\n  \n  return matches.slice(0, 5); // Limit to 5 matches per result\n}\n\nexport async function searchByTags(\n  directory: string,\n  tags: string[]\n): Promise<ContentFile[]> {\n  const filePaths = await findContentFiles(directory);\n  const matchingFiles: ContentFile[] = [];\n  \n  for (const filePath of filePaths) {\n    try {\n      const file = await readContentFile(filePath);\n      \n      if (file.frontmatter?.tags) {\n        const fileTags = Array.isArray(file.frontmatter.tags) \n          ? file.frontmatter.tags \n          : [file.frontmatter.tags];\n          \n        const hasMatchingTag = tags.some(tag => \n          fileTags.some((fileTag: any) => \n            typeof fileTag === 'string' && \n            fileTag.toLowerCase() === tag.toLowerCase()\n          )\n        );\n        \n        if (hasMatchingTag) {\n          matchingFiles.push(file);\n        }\n      }\n    } catch (error) {\n      console.warn(`Failed to read file ${filePath}:`, error);\n      continue;\n    }\n  }\n  \n  return matchingFiles.sort((a, b) => b.lastModified.getTime() - a.lastModified.getTime());\n}\n\nexport async function searchByDateRange(\n  directory: string,\n  startDate: Date,\n  endDate: Date\n): Promise<ContentFile[]> {\n  const filePaths = await findContentFiles(directory);\n  const matchingFiles: ContentFile[] = [];\n  \n  for (const filePath of filePaths) {\n    try {\n      const file = await readContentFile(filePath);\n      \n      if (file.lastModified >= startDate && file.lastModified <= endDate) {\n        matchingFiles.push(file);\n      }\n    } catch (error) {\n      console.warn(`Failed to read file ${filePath}:`, error);\n      continue;\n    }\n  }\n  \n  return matchingFiles.sort((a, b) => b.lastModified.getTime() - a.lastModified.getTime());\n}\n","import { z } from 'zod';\nimport { \n  renderMarkdown, \n  generateTableOfContents, \n  extractHeadings,\n  extractFrontmatter \n} from '../utils/markdownUtils.js';\nimport { \n  searchNotes, \n  searchByTags, \n  searchByDateRange \n} from '../utils/searchUtils.js';\nimport { \n  getDirectoryStats, \n  findContentFiles, \n  readContentFile \n} from '../utils/fileUtils.js';\n\n// Tool argument schemas with Zod validation\nexport const RenderMarkdownArgsSchema = z.object({\n  content: z.string().min(1, 'Content cannot be empty'),\n  generateToc: z.boolean().default(true),\n  sanitizeHtml: z.boolean().default(true),\n  enableCodeHighlight: z.boolean().default(true)\n});\n\nexport const SearchNotesArgsSchema = z.object({\n  query: z.string().min(1, 'Query cannot be empty'),\n  directory: z.string().optional(),\n  includeContent: z.boolean().default(true),\n  maxResults: z.number().int().positive().default(10),\n  fuzzy: z.boolean().default(true)\n});\n\nexport const SearchByTagsArgsSchema = z.object({\n  tags: z.array(z.string()).min(1, 'At least one tag is required'),\n  directory: z.string().default(process.cwd())\n});\n\nexport const SearchByDateRangeArgsSchema = z.object({\n  startDate: z.string().refine((val) => !isNaN(Date.parse(val)), 'Invalid start date'),\n  endDate: z.string().refine((val) => !isNaN(Date.parse(val)), 'Invalid end date'),\n  directory: z.string().default(process.cwd())\n});\n\nexport const GenerateTableOfContentsArgsSchema = z.object({\n  content: z.string().min(1, 'Content cannot be empty')\n});\n\nexport const ExtractHeadingsArgsSchema = z.object({\n  content: z.string().min(1, 'Content cannot be empty')\n});\n\nexport const ExtractFrontmatterArgsSchema = z.object({\n  content: z.string().min(1, 'Content cannot be empty')\n});\n\nexport const GetDirectoryStatsArgsSchema = z.object({\n  directory: z.string().default(process.cwd())\n});\n\nexport const FindContentFilesArgsSchema = z.object({\n  directory: z.string().default(process.cwd()),\n  extensions: z.array(z.string()).default(['.md', '.markdown', '.txt', '.mdx'])\n});\n\nexport const ReadContentFileArgsSchema = z.object({\n  filePath: z.string().min(1, 'File path cannot be empty')\n});\n\n// Tool implementations\nexport const tools = {\n  render_markdown: {\n    description: 'Render Markdown content to HTML with optional table of contents generation and HTML sanitization',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        content: {\n          type: 'string',\n          description: 'The Markdown content to render'\n        },\n        generateToc: {\n          type: 'boolean',\n          description: 'Whether to generate a table of contents',\n          default: true\n        },\n        sanitizeHtml: {\n          type: 'boolean',\n          description: 'Whether to sanitize the resulting HTML',\n          default: true\n        },\n        enableCodeHighlight: {\n          type: 'boolean',\n          description: 'Whether to enable code syntax highlighting',\n          default: true\n        }\n      },\n      required: ['content']\n    },\n    handler: async (args: any) => {\n      const { content, generateToc, sanitizeHtml, enableCodeHighlight } = \n        RenderMarkdownArgsSchema.parse(args);\n      \n      const html = renderMarkdown(content, { \n        generateToc, \n        sanitizeHtml, \n        enableCodeHighlight \n      });\n      \n      return {\n        content: [{ type: 'text', text: html }]\n      };\n    }\n  },\n\n  search_notes: {\n    description: 'Search through notes and documents using fuzzy or exact matching',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        query: {\n          type: 'string',\n          description: 'The search query'\n        },\n        directory: {\n          type: 'string',\n          description: 'The directory to search in (defaults to current directory)'\n        },\n        includeContent: {\n          type: 'boolean',\n          description: 'Whether to include file content in results',\n          default: true\n        },\n        maxResults: {\n          type: 'number',\n          description: 'Maximum number of results to return',\n          default: 10\n        },\n        fuzzy: {\n          type: 'boolean',\n          description: 'Whether to use fuzzy search',\n          default: true\n        }\n      },\n      required: ['query']\n    },\n    handler: async (args: any) => {\n      const searchOptions = SearchNotesArgsSchema.parse(args);\n      const results = await searchNotes(searchOptions);\n      \n      const formattedResults = results.map((result, index) => {\n        const { file, score, matches } = result;\n        return `**Result ${index + 1}** (Score: ${(score * 100).toFixed(1)}%)\n**File:** ${file.name}\n**Path:** ${file.path}\n**Last Modified:** ${file.lastModified.toISOString()}\n**Matches:**\n${matches.map(match => `- ${match}`).join('\\\\n')}\n${searchOptions.includeContent && file.content ? `\\\\n**Content Preview:**\\\\n${file.content.slice(0, 200)}...` : ''}\n---`;\n      }).join('\\\\n\\\\n');\n      \n      return {\n        content: [{ \n          type: 'text', \n          text: results.length > 0 ? formattedResults : 'No results found for the given query.' \n        }]\n      };\n    }\n  },\n\n  search_by_tags: {\n    description: 'Search for files by tags in their frontmatter',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        tags: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'Array of tags to search for'\n        },\n        directory: {\n          type: 'string',\n          description: 'The directory to search in',\n          default: process.cwd()\n        }\n      },\n      required: ['tags']\n    },\n    handler: async (args: any) => {\n      const { tags, directory } = SearchByTagsArgsSchema.parse(args);\n      const results = await searchByTags(directory, tags);\n      \n      if (results.length === 0) {\n        return {\n          content: [{ type: 'text', text: `No files found with tags: ${tags.join(', ')}` }]\n        };\n      }\n      \n      const formattedResults = results.map((file, index) => {\n        const fileTags = file.frontmatter?.tags || [];\n        return `**${index + 1}. ${file.name}**\nPath: ${file.path}\nTags: ${Array.isArray(fileTags) ? fileTags.join(', ') : fileTags}\nLast Modified: ${file.lastModified.toISOString()}\nSize: ${file.size} bytes`;\n      }).join('\\\\n\\\\n');\n      \n      return {\n        content: [{ type: 'text', text: formattedResults }]\n      };\n    }\n  },\n\n  search_by_date_range: {\n    description: 'Search for files modified within a specific date range',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        startDate: {\n          type: 'string',\n          description: 'Start date in ISO format (YYYY-MM-DD)'\n        },\n        endDate: {\n          type: 'string',\n          description: 'End date in ISO format (YYYY-MM-DD)'\n        },\n        directory: {\n          type: 'string',\n          description: 'The directory to search in',\n          default: process.cwd()\n        }\n      },\n      required: ['startDate', 'endDate']\n    },\n    handler: async (args: any) => {\n      const { startDate, endDate, directory } = SearchByDateRangeArgsSchema.parse(args);\n      const results = await searchByDateRange(\n        directory, \n        new Date(startDate), \n        new Date(endDate)\n      );\n      \n      if (results.length === 0) {\n        return {\n          content: [{ type: 'text', text: `No files found between ${startDate} and ${endDate}` }]\n        };\n      }\n      \n      const formattedResults = results.map((file, index) => {\n        return `**${index + 1}. ${file.name}**\nPath: ${file.path}\nLast Modified: ${file.lastModified.toISOString()}\nSize: ${file.size} bytes`;\n      }).join('\\\\n\\\\n');\n      \n      return {\n        content: [{ type: 'text', text: formattedResults }]\n      };\n    }\n  },\n\n  generate_table_of_contents: {\n    description: 'Generate a table of contents from Markdown content',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        content: {\n          type: 'string',\n          description: 'The Markdown content to analyze'\n        }\n      },\n      required: ['content']\n    },\n    handler: async (args: any) => {\n      const { content } = GenerateTableOfContentsArgsSchema.parse(args);\n      const toc = generateTableOfContents(content);\n      \n      return {\n        content: [{ \n          type: 'text', \n          text: toc || 'No headings found in the content.' \n        }]\n      };\n    }\n  },\n\n  extract_headings: {\n    description: 'Extract all headings from Markdown content',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        content: {\n          type: 'string',\n          description: 'The Markdown content to analyze'\n        }\n      },\n      required: ['content']\n    },\n    handler: async (args: any) => {\n      const { content } = ExtractHeadingsArgsSchema.parse(args);\n      const headings = extractHeadings(content);\n      \n      if (headings.length === 0) {\n        return {\n          content: [{ type: 'text', text: 'No headings found in the content.' }]\n        };\n      }\n      \n      const formattedHeadings = headings.map(heading => {\n        const indent = '  '.repeat(heading.level - 1);\n        return `${indent}${'#'.repeat(heading.level)} ${heading.text} (id: ${heading.id})`;\n      }).join('\\\\n');\n      \n      return {\n        content: [{ type: 'text', text: formattedHeadings }]\n      };\n    }\n  },\n\n  extract_frontmatter: {\n    description: 'Extract frontmatter from Markdown content',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        content: {\n          type: 'string',\n          description: 'The Markdown content to analyze'\n        }\n      },\n      required: ['content']\n    },\n    handler: async (args: any) => {\n      const { content } = ExtractFrontmatterArgsSchema.parse(args);\n      const { frontmatter, content: contentWithoutFrontmatter } = extractFrontmatter(content);\n      \n      const result = {\n        frontmatter,\n        contentLength: contentWithoutFrontmatter.length,\n        hasFrontmatter: Object.keys(frontmatter).length > 0\n      };\n      \n      return {\n        content: [{ \n          type: 'text', \n          text: JSON.stringify(result, null, 2) \n        }]\n      };\n    }\n  },\n\n  get_directory_stats: {\n    description: 'Get statistics about content files in a directory',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        directory: {\n          type: 'string',\n          description: 'The directory to analyze',\n          default: process.cwd()\n        }\n      }\n    },\n    handler: async (args: any) => {\n      const { directory } = GetDirectoryStatsArgsSchema.parse(args);\n      const stats = await getDirectoryStats(directory);\n      \n      const result = {\n        directory,\n        ...stats,\n        lastUpdated: new Date().toISOString(),\n        averageFileSize: stats.totalFiles > 0 ? Math.round(stats.totalSize / stats.totalFiles) : 0\n      };\n      \n      return {\n        content: [{ \n          type: 'text', \n          text: JSON.stringify(result, null, 2) \n        }]\n      };\n    }\n  },\n\n  find_content_files: {\n    description: 'Find all content files in a directory with specific extensions',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        directory: {\n          type: 'string',\n          description: 'The directory to search in',\n          default: process.cwd()\n        },\n        extensions: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'File extensions to search for',\n          default: ['.md', '.markdown', '.txt', '.mdx']\n        }\n      }\n    },\n    handler: async (args: any) => {\n      const { directory, extensions } = FindContentFilesArgsSchema.parse(args);\n      const files = await findContentFiles(directory, extensions);\n      \n      if (files.length === 0) {\n        return {\n          content: [{ type: 'text', text: `No files found with extensions: ${extensions.join(', ')}` }]\n        };\n      }\n      \n      const formattedFiles = files.map((file, index) => \n        `${index + 1}. ${file}`\n      ).join('\\\\n');\n      \n      return {\n        content: [{ \n          type: 'text', \n          text: `Found ${files.length} files:\\\\n\\\\n${formattedFiles}` \n        }]\n      };\n    }\n  },\n\n  read_content_file: {\n    description: 'Read and parse a content file (supports Markdown with frontmatter)',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        filePath: {\n          type: 'string',\n          description: 'Path to the file to read'\n        }\n      },\n      required: ['filePath']\n    },\n    handler: async (args: any) => {\n      const { filePath } = ReadContentFileArgsSchema.parse(args);\n      const file = await readContentFile(filePath);\n      \n      const result = {\n        name: file.name,\n        path: file.path,\n        size: file.size,\n        lastModified: file.lastModified.toISOString(),\n        hasFrontmatter: !!file.frontmatter && Object.keys(file.frontmatter).length > 0,\n        frontmatter: file.frontmatter,\n        contentPreview: file.content.slice(0, 500) + (file.content.length > 500 ? '...' : ''),\n        contentLength: file.content.length\n      };\n      \n      return {\n        content: [{ \n          type: 'text', \n          text: JSON.stringify(result, null, 2) \n        }]\n      };\n    }\n  }\n} as const;","#!/usr/bin/env node\n\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from '@modelcontextprotocol/sdk/types.js';\nimport { tools } from './tools/index';\n\nclass ContentManagerMCPServer {\n  private server: Server;\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: 'content-manager-mcp',\n        version: '1.0.0'\n      }\n    );\n\n    this.setupToolHandlers();\n    this.setupErrorHandling();\n  }\n\n  private setupToolHandlers(): void {\n    this.server.setRequestHandler(ListToolsRequestSchema, async () => {\n      return {\n        tools: Object.entries(tools).map(([name, tool]) => ({\n          name,\n          description: tool.description,\n          inputSchema: tool.inputSchema,\n        })),\n      };\n    });\n\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {\n      const { name, arguments: args } = request.params;\n\n      if (!name || !(name in tools)) {\n        throw new Error(`Unknown tool: ${name}`);\n      }\n\n      try {\n        const tool = tools[name as keyof typeof tools];\n        const result = await tool.handler(args ?? {});\n        return result;\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n        \n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error executing tool \"${name}\": ${errorMessage}`\n            }\n          ],\n          isError: true\n        };\n      }\n    });\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) => {\n      console.error('[MCP Error]', error);\n    };\n\n    process.on('SIGINT', async () => {\n      await this.server.close();\n      process.exit(0);\n    });\n\n    process.on('SIGTERM', async () => {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  async run(): Promise<void> {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n\n    // Log server info to stderr (won't interfere with MCP protocol on stdout)\n    console.error('Content Manager MCP Server running on stdio');\n    console.error('Available tools:', Object.keys(tools).join(', '));\n  }\n}\n\n// Main execution\nasync function main(): Promise<void> {\n  const server = new ContentManagerMCPServer();\n  await server.run();\n}\n\n// Handle uncaught errors\nprocess.on('uncaughtException', (error) => {\n  console.error('Uncaught Exception:', error);\n  process.exit(1);\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('Unhandled Rejection at:', promise, 'reason:', reason);\n  process.exit(1);\n});\n\nif (import.meta.url === `file://${process.argv[1]}`) {\n  main().catch((error: unknown) => {\n    console.error('Failed to start server:', error);\n    process.exit(1);\n  });\n}\n"]}